// This sketch program ESP32 by flashing bin file from on-flash (with .h header)
// Hardware wiring:
// - Brain GPIO28 <-> ESP32 IO0
// - Brain Reset  <-> ESP32 Enable
// - Brain TX/RX  <-> ESP32 RX/TX

// required for Host MSC block device
#include "SdFat.h"

// required for USB host
#include "pio_usb.h"
#include "Adafruit_TinyUSB.h"

#include "Adafruit_TestBed_Brains.h"

#include "esp_binaries.h"

#define ESP32_RESET     27
#define ESP32_IO0       28

#define ESP32_BAUDRATE  2000000
//#define ESP32_BAUDRATE  921600
//#define ESP32_BAUDRATE  115200

#if 0
// Bin files on SDCard to program
// These files can be generated by any of Arduino sketches
// The example use WiFiAccessPoint sketch, which we can verify its running image
// by simply scan for existence of ssid "YourAP"
struct {
  uint32_t addr;
  const char* fpath;
} bin_list [] = {
  { 0x1000  , "esp32/WiFiAccessPoint/WiFiAccessPoint.ino.bootloader.bin" },
  { 0x8000  , "esp32/WiFiAccessPoint/WiFiAccessPoint.ino.partitions.bin" },
  { 0xe000  , "esp32/WiFiAccessPoint/boot_app0.bin"                      },
  { 0x10000 , "esp32/WiFiAccessPoint/WiFiAccessPoint.ino.bin"            },
};

#else

// Compressed binaries files generated by tools/esp_compress.py
struct {
  uint32_t addr;
  esp32_zipfile_t const * zfile;
} bin_list[] = {
  { 0xe000, &boot_app0 }
};

#endif

enum {
  BIN_LIST_COUNT = sizeof(bin_list)/sizeof(bin_list[0])
};


// Defined an boot rom object that use UART Serial1
ESP32BootROMClass ESP32BootROM(Serial1, ESP32_IO0, ESP32_RESET);

//--------------------------------------------------------------------+
// Setup and Loop on Core0
//--------------------------------------------------------------------+

void print_speed(size_t count, uint32_t ms) {
  Brain.LCD_printf(0, "%.01fKB %.01fs", count/1000.0F, ms / 1000.0F);

  Serial.printf("Completed %u bytes in %.02f seconds.\r\n", count, ms / 1000.0F);
  Serial.printf("Speed : %.02f KB/s\r\n", (count / 1000.0F) / (ms / 1000.0F));
}

void setup() {
  Serial.begin(115200);
  while (!Serial) delay(10);
  Serial.println("Tester Brains: Programming ESP32 with UART!");

  Brain.begin();

  while ( !Brain.esp32_begin(&ESP32BootROM, ESP32_BAUDRATE) ) {
    // retry syncing
    delay(100);
  }

  // Writing bin files
  size_t total_bytes = 0;
  uint32_t ms = millis();
  for(size_t i=0; i<BIN_LIST_COUNT; i++) {
    Brain.LCD_printf("Flashing file %u", i);
    size_t wr_count = Brain.esp32_programFlashDefl(bin_list[i].zfile, bin_list[i].addr);
    total_bytes += wr_count;
    if (!wr_count) {
      Brain.LCD_printf_error("Failed to flash");
    }
  }
  print_speed(total_bytes, millis() - ms);

  Brain.esp32_end();

  // reset ESP32 to run new firmware
  Brain.targetReset();
}

void loop() {
}

//--------------------------------------------------------------------+
// Setup and Loop on Core1
//--------------------------------------------------------------------+

// call usbh_begin() here to make pio usb background task run on core1
// NOTE: Brain.begin() should be called here as well to prevent race condition
void setup1() {

}

// core1's loop: process usb host task on core1
void loop1() {
  yield();
}

//--------------------------------------------------------------------+
// TinyUSB Host callbacks
// Note: running in the same core where Brain.USBHost.task() is called
//--------------------------------------------------------------------+
extern "C"  {

// Invoked when device is mounted (configured)
void tuh_mount_cb (uint8_t dev_addr)
{
  (void) dev_addr;
}

/// Invoked when device is unmounted (bus reset/unplugged)
void tuh_umount_cb(uint8_t dev_addr)
{
  (void) dev_addr;
}

}
